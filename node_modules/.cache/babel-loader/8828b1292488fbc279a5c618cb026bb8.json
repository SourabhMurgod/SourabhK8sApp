{"ast":null,"code":"/*!\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Buffer } from 'buffer';\nimport { Sha256 } from '@aws-crypto/sha256-js';\nimport { Platform } from './Platform';\nimport BigInteger from './BigInteger';\nimport AuthenticationHelper from './AuthenticationHelper';\nimport CognitoAccessToken from './CognitoAccessToken';\nimport CognitoIdToken from './CognitoIdToken';\nimport CognitoRefreshToken from './CognitoRefreshToken';\nimport CognitoUserSession from './CognitoUserSession';\nimport DateHelper from './DateHelper';\nimport CognitoUserAttribute from './CognitoUserAttribute';\nimport StorageHelper from './StorageHelper';\n/**\n * @callback nodeCallback\n * @template T result\n * @param {*} err The operation failure reason, or null.\n * @param {T} result The operation result.\n */\n\n/**\n * @callback onFailure\n * @param {*} err Failure reason.\n */\n\n/**\n * @callback onSuccess\n * @template T result\n * @param {T} result The operation result.\n */\n\n/**\n * @callback mfaRequired\n * @param {*} details MFA challenge details.\n */\n\n/**\n * @callback customChallenge\n * @param {*} details Custom challenge details.\n */\n\n/**\n * @callback inputVerificationCode\n * @param {*} data Server response.\n */\n\n/**\n * @callback authSuccess\n * @param {CognitoUserSession} session The new session.\n * @param {bool=} userConfirmationNecessary User must be confirmed.\n */\n\nvar isNavigatorAvailable = typeof navigator !== 'undefined';\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? 'react-native' : navigator.userAgent : 'nodejs';\n/** @class */\n\nvar CognitoUser = /*#__PURE__*/function () {\n  /**\n   * Constructs a new CognitoUser object\n   * @param {object} data Creation options\n   * @param {string} data.Username The user's username.\n   * @param {CognitoUserPool} data.Pool Pool containing the user.\n   * @param {object} data.Storage Optional storage object.\n   */\n  function CognitoUser(data) {\n    if (data == null || data.Username == null || data.Pool == null) {\n      throw new Error('Username and Pool information are required.');\n    }\n\n    this.username = data.Username || '';\n    this.pool = data.Pool;\n    this.Session = null;\n    this.client = data.Pool.client;\n    this.signInUserSession = null;\n    this.authenticationFlowType = 'USER_SRP_AUTH';\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\n  }\n  /**\n   * Sets the session for this user\n   * @param {CognitoUserSession} signInUserSession the session\n   * @returns {void}\n   */\n\n\n  var _proto = CognitoUser.prototype;\n\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\n    this.clearCachedUserData();\n    this.signInUserSession = signInUserSession;\n    this.cacheTokens();\n  }\n  /**\n   * @returns {CognitoUserSession} the current session for this user\n   */\n  ;\n\n  _proto.getSignInUserSession = function getSignInUserSession() {\n    return this.signInUserSession;\n  }\n  /**\n   * @returns {string} the user's username\n   */\n  ;\n\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  }\n  /**\n   * @returns {String} the authentication flow type\n   */\n  ;\n\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\n    return this.authenticationFlowType;\n  }\n  /**\n   * sets authentication flow type\n   * @param {string} authenticationFlowType New value.\n   * @returns {void}\n   */\n  ;\n\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\n    this.authenticationFlowType = authenticationFlowType;\n  }\n  /**\n   * This is used for authenticating the user through the custom authentication flow.\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */\n  ;\n\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\n    var _this = this;\n\n    var authParameters = authDetails.getAuthParameters();\n    authParameters.USERNAME = this.username;\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'CUSTOM_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('InitiateAuth', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      var challengeName = data.ChallengeName;\n      var challengeParameters = data.ChallengeParameters;\n\n      if (challengeName === 'CUSTOM_CHALLENGE') {\n        _this.Session = data.Session;\n        return callback.customChallenge(challengeParameters);\n      }\n\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\n\n      _this.cacheTokens();\n\n      return callback.onSuccess(_this.signInUserSession);\n    });\n  }\n  /**\n   * This is used for authenticating the user.\n   * stuff\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {newPasswordRequired} callback.newPasswordRequired new\n   *        password and any required attributes are required to continue\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */\n  ;\n\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\n    if (this.authenticationFlowType === 'USER_PASSWORD_AUTH') {\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\n    } else if (this.authenticationFlowType === 'USER_SRP_AUTH' || this.authenticationFlowType === 'CUSTOM_AUTH') {\n      return this.authenticateUserDefaultAuth(authDetails, callback);\n    }\n\n    return callback.onFailure(new Error('Authentication flow type is invalid.'));\n  }\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * It calls the AuthenticationHelper for SRP related\n   * stuff\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {newPasswordRequired} callback.newPasswordRequired new\n   *        password and any required attributes are required to continue\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */\n  ;\n\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\n    var _this2 = this;\n\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var dateHelper = new DateHelper();\n    var serverBValue;\n    var salt;\n    var authParameters = {};\n\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n\n    authParameters.USERNAME = this.username;\n    authenticationHelper.getLargeAValue(function (errOnAValue, aValue) {\n      // getLargeAValue callback start\n      if (errOnAValue) {\n        callback.onFailure(errOnAValue);\n      }\n\n      authParameters.SRP_A = aValue.toString(16);\n\n      if (_this2.authenticationFlowType === 'CUSTOM_AUTH') {\n        authParameters.CHALLENGE_NAME = 'SRP_A';\n      }\n\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n      var jsonReq = {\n        AuthFlow: _this2.authenticationFlowType,\n        ClientId: _this2.pool.getClientId(),\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetaData\n      };\n\n      if (_this2.getUserContextData(_this2.username)) {\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\n      }\n\n      _this2.client.request('InitiateAuth', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        var challengeParameters = data.ChallengeParameters;\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\n        serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        salt = new BigInteger(challengeParameters.SALT, 16);\n\n        _this2.getCachedDeviceKeyAndPassword();\n\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function (errOnHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errOnHkdf) {\n            callback.onFailure(errOnHkdf);\n          }\n\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this2.pool.getUserPoolName(), 'utf8'), Buffer.from(_this2.username, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this2.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n\n          if (_this2.deviceKey != null) {\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\n          }\n\n          var respondToAuthChallenge = function respondToAuthChallenge(challenge, challengeCallback) {\n            return _this2.client.request('RespondToAuthChallenge', challenge, function (errChallenge, dataChallenge) {\n              if (errChallenge && errChallenge.code === 'ResourceNotFoundException' && errChallenge.message.toLowerCase().indexOf('device') !== -1) {\n                challengeResponses.DEVICE_KEY = null;\n                _this2.deviceKey = null;\n                _this2.randomPassword = null;\n                _this2.deviceGroupKey = null;\n\n                _this2.clearCachedDeviceKeyAndPassword();\n\n                return respondToAuthChallenge(challenge, challengeCallback);\n              }\n\n              return challengeCallback(errChallenge, dataChallenge);\n            });\n          };\n\n          var jsonReqResp = {\n            ChallengeName: 'PASSWORD_VERIFIER',\n            ClientId: _this2.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session,\n            ClientMetadata: clientMetaData\n          };\n\n          if (_this2.getUserContextData()) {\n            jsonReqResp.UserContextData = _this2.getUserContextData();\n          }\n\n          respondToAuthChallenge(jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n          });\n          return undefined; // getPasswordAuthenticationKey callback end\n        });\n        return undefined;\n      }); // getLargeAValue callback end\n\n    });\n  }\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * @param {AuthenticationDetails} authDetails Contains the authentication data.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */\n  ;\n\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\n    var _this3 = this;\n\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.PASSWORD = authDetails.getPassword();\n\n    if (!authParameters.PASSWORD) {\n      callback.onFailure(new Error('PASSWORD parameter is required'));\n      return;\n    }\n\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'USER_PASSWORD_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n\n    if (this.getUserContextData(this.username)) {\n      jsonReq.UserContextData = this.getUserContextData(this.username);\n    } // USER_PASSWORD_AUTH happens in a single round-trip: client sends userName and password,\n    // Cognito UserPools verifies password and returns tokens.\n\n\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\n    });\n  }\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * @param {object} dataAuthenticate authentication data\n   * @param {object} authenticationHelper helper created\n   * @param {callback} callback passed on from caller\n   * @returns {void}\n   */\n  ;\n\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\n    var _this4 = this;\n\n    var challengeName = dataAuthenticate.ChallengeName;\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\n\n    if (challengeName === 'SMS_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaRequired(challengeName, challengeParameters);\n    }\n\n    if (challengeName === 'SELECT_MFA_TYPE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.selectMFAType(challengeName, challengeParameters);\n    }\n\n    if (challengeName === 'MFA_SETUP') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaSetup(challengeName, challengeParameters);\n    }\n\n    if (challengeName === 'SOFTWARE_TOKEN_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.totpRequired(challengeName, challengeParameters);\n    }\n\n    if (challengeName === 'CUSTOM_CHALLENGE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.customChallenge(challengeParameters);\n    }\n\n    if (challengeName === 'NEW_PASSWORD_REQUIRED') {\n      this.Session = dataAuthenticate.Session;\n      var userAttributes = null;\n      var rawRequiredAttributes = null;\n      var requiredAttributes = [];\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n\n      if (challengeParameters) {\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\n      }\n\n      if (rawRequiredAttributes) {\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\n        }\n      }\n\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\n    }\n\n    if (challengeName === 'DEVICE_SRP_AUTH') {\n      this.Session = dataAuthenticate.Session;\n      this.getDeviceResponse(callback);\n      return undefined;\n    }\n\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n    this.challengeName = challengeName;\n    this.cacheTokens();\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\n\n    if (newDeviceMetadata == null) {\n      return callback.onSuccess(this.signInUserSession);\n    }\n\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n      if (errGenHash) {\n        return callback.onFailure(errGenHash);\n      }\n\n      var deviceSecretVerifierConfig = {\n        Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n        PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n      };\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\n\n      _this4.client.request('ConfirmDevice', {\n        DeviceKey: newDeviceMetadata.DeviceKey,\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        DeviceName: userAgent\n      }, function (errConfirm, dataConfirm) {\n        if (errConfirm) {\n          return callback.onFailure(errConfirm);\n        }\n\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n\n        _this4.cacheDeviceKeyAndPassword();\n\n        if (dataConfirm.UserConfirmationNecessary === true) {\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\n        }\n\n        return callback.onSuccess(_this4.signInUserSession);\n      });\n\n      return undefined;\n    });\n    return undefined;\n  }\n  /**\n   * This method is user to complete the NEW_PASSWORD_REQUIRED challenge.\n   * Pass the new password with any new user attributes to be updated.\n   * User attribute keys must be of format userAttributes.<attribute_name>.\n   * @param {string} newPassword new password for this user\n   * @param {object} requiredAttributeData map with values for all required attributes\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {mfaRequired} callback.mfaRequired MFA code required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *         response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\n    var _this5 = this;\n\n    if (!newPassword) {\n      return callback.onFailure(new Error('New password is required.'));\n    }\n\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n    var finalUserAttributes = {};\n\n    if (requiredAttributeData) {\n      Object.keys(requiredAttributeData).forEach(function (key) {\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\n      });\n    }\n\n    finalUserAttributes.NEW_PASSWORD = newPassword;\n    finalUserAttributes.USERNAME = this.username;\n    var jsonReq = {\n      ChallengeName: 'NEW_PASSWORD_REQUIRED',\n      ClientId: this.pool.getClientId(),\n      ChallengeResponses: finalUserAttributes,\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('RespondToAuthChallenge', jsonReq, function (errAuthenticate, dataAuthenticate) {\n      if (errAuthenticate) {\n        return callback.onFailure(errAuthenticate);\n      }\n\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n    });\n    return undefined;\n  }\n  /**\n   * This is used to get a session using device authentication. It is called at the end of user\n   * authentication\n   *\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   * @private\n   */\n  ;\n\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\n    var _this6 = this;\n\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\n    var dateHelper = new DateHelper();\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.DEVICE_KEY = this.deviceKey;\n    authenticationHelper.getLargeAValue(function (errAValue, aValue) {\n      // getLargeAValue callback start\n      if (errAValue) {\n        callback.onFailure(errAValue);\n      }\n\n      authParameters.SRP_A = aValue.toString(16);\n      var jsonReq = {\n        ChallengeName: 'DEVICE_SRP_AUTH',\n        ClientId: _this6.pool.getClientId(),\n        ChallengeResponses: authParameters,\n        ClientMetadata: clientMetadata,\n        Session: _this6.Session\n      };\n\n      if (_this6.getUserContextData()) {\n        jsonReq.UserContextData = _this6.getUserContextData();\n      }\n\n      _this6.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        var challengeParameters = data.ChallengeParameters;\n        var serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        var salt = new BigInteger(challengeParameters.SALT, 16);\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function (errHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errHkdf) {\n            return callback.onFailure(errHkdf);\n          }\n\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this6.deviceGroupKey, 'utf8'), Buffer.from(_this6.deviceKey, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this6.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\n          var jsonReqResp = {\n            ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n            ClientId: _this6.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session\n          };\n\n          if (_this6.getUserContextData()) {\n            jsonReqResp.UserContextData = _this6.getUserContextData();\n          }\n\n          _this6.client.request('RespondToAuthChallenge', jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n\n            _this6.cacheTokens();\n\n            return callback.onSuccess(_this6.signInUserSession);\n          });\n\n          return undefined; // getPasswordAuthenticationKey callback end\n        });\n        return undefined;\n      }); // getLargeAValue callback end\n\n    });\n  }\n  /**\n   * This is used for a certain user to confirm the registration by using a confirmation code\n   * @param {string} confirmationCode Code entered by user.\n   * @param {bool} forceAliasCreation Allow migrating from an existing email / phone number.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      ConfirmationCode: confirmationCode,\n      Username: this.username,\n      ForceAliasCreation: forceAliasCreation,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('ConfirmSignUp', jsonReq, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, 'SUCCESS');\n    });\n  }\n  /**\n   * This is used by the user once he has the responses to a custom challenge\n   * @param {string} answerChallenge The custom challenge answer.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {customChallenge} callback.customChallenge\n   *    Custom challenge response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\n    var _this7 = this;\n\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n\n    var jsonReq = {\n      ChallengeName: 'CUSTOM_CHALLENGE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\n    });\n  }\n  /**\n   * This is used by the user once he has an MFA code\n   * @param {string} confirmationCode The MFA code entered by the user.\n   * @param {object} callback Result callback map.\n   * @param {string} mfaType The mfa we are replying to.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\n    var _this8 = this;\n\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\n    var mfaTypeSelection = mfaType || 'SMS_MFA';\n\n    if (mfaTypeSelection === 'SOFTWARE_TOKEN_MFA') {\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\n    }\n\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n\n    var jsonReq = {\n      ChallengeName: mfaTypeSelection,\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, dataAuthenticate) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      var challengeName = dataAuthenticate.ChallengeName;\n\n      if (challengeName === 'DEVICE_SRP_AUTH') {\n        _this8.getDeviceResponse(callback);\n\n        return undefined;\n      }\n\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n\n      _this8.cacheTokens();\n\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\n        return callback.onSuccess(_this8.signInUserSession);\n      }\n\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n        if (errGenHash) {\n          return callback.onFailure(errGenHash);\n        }\n\n        var deviceSecretVerifierConfig = {\n          Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n          PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n        };\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\n\n        _this8.client.request('ConfirmDevice', {\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n          DeviceName: userAgent\n        }, function (errConfirm, dataConfirm) {\n          if (errConfirm) {\n            return callback.onFailure(errConfirm);\n          }\n\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n\n          _this8.cacheDeviceKeyAndPassword();\n\n          if (dataConfirm.UserConfirmationNecessary === true) {\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\n          }\n\n          return callback.onSuccess(_this8.signInUserSession);\n        });\n\n        return undefined;\n      });\n      return undefined;\n    });\n  }\n  /**\n   * This is used by an authenticated user to change the current password\n   * @param {string} oldUserPassword The current password.\n   * @param {string} newUserPassword The requested new password.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('ChangePassword', {\n      PreviousPassword: oldUserPassword,\n      ProposedPassword: newUserPassword,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used by an authenticated user to enable MFA for itself\n   * @deprecated\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.enableMFA = function enableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    var mfaOptions = [];\n    var mfaEnabled = {\n      DeliveryMedium: 'SMS',\n      AttributeName: 'phone_number'\n    };\n    mfaOptions.push(mfaEnabled);\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used by an authenticated user to enable MFA for itself\n   * @param {IMfaSettings} smsMfaSettings the sms mfa settings\n   * @param {IMFASettings} softwareTokenMfaSettings the software token mfa settings\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('SetUserMFAPreference', {\n      SMSMfaSettings: smsMfaSettings,\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used by an authenticated user to disable MFA for itself\n   * @deprecated\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.disableMFA = function disableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    var mfaOptions = [];\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used by an authenticated user to delete itself\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\n    var _this9 = this;\n\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('DeleteUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      _this9.clearCachedUser();\n\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * @typedef {CognitoUserAttribute | { Name:string, Value:string }} AttributeArg\n   */\n\n  /**\n   * This is used by an authenticated user to change a list of attributes\n   * @param {AttributeArg[]} attributes A list of the new user attributes.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\n    var _this10 = this;\n\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('UpdateUserAttributes', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      UserAttributes: attributes,\n      ClientMetadata: clientMetadata\n    }, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      } // update cached user\n\n\n      return _this10.getUserData(function () {\n        return callback(null, 'SUCCESS', result);\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n  /**\n   * This is used by an authenticated user to get a list of attributes\n   * @param {nodeCallback<CognitoUserAttribute[]>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.getUserAttributes = function getUserAttributes(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      var attributeList = [];\n\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\n        var attribute = {\n          Name: userData.UserAttributes[i].Name,\n          Value: userData.UserAttributes[i].Value\n        };\n        var userAttribute = new CognitoUserAttribute(attribute);\n        attributeList.push(userAttribute);\n      }\n\n      return callback(null, attributeList);\n    });\n    return undefined;\n  }\n  /**\n   * This was previously used by an authenticated user to get MFAOptions,\n   * but no longer returns a meaningful response. Refer to the documentation for\n   * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\n   * @deprecated\n   * @param {nodeCallback<MFAOptions>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.getMFAOptions = function getMFAOptions(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, userData.MFAOptions);\n    });\n    return undefined;\n  }\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */\n  ;\n\n  _proto.createGetUserRequest = function createGetUserRequest() {\n    return this.client.promisifyRequest('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    });\n  }\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */\n  ;\n\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\n    var _this11 = this;\n\n    if (options === void 0) {\n      options = {};\n    } // best effort, if not possible\n\n\n    return new Promise(function (resolve) {\n      var refresh = _this11.signInUserSession.getRefreshToken();\n\n      if (refresh && refresh.getToken()) {\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\n      } else {\n        resolve();\n      }\n    });\n  }\n  /**\n   * @typedef {Object} GetUserDataOptions\n   * @property {boolean} bypassCache - force getting data from Cognito service\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\n   */\n\n  /**\n   * This is used by an authenticated users to get the userData\n   * @param {nodeCallback<UserData>} callback Called on success or error.\n   * @param {GetUserDataOptions} params\n   * @returns {void}\n   */\n  ;\n\n  _proto.getUserData = function getUserData(callback, params) {\n    var _this12 = this;\n\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.clearCachedUserData();\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    var userData = this.getUserDataFromCache();\n\n    if (!userData) {\n      this.fetchUserData().then(function (data) {\n        callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n\n    if (this.isFetchUserDataAndTokenRequired(params)) {\n      this.fetchUserData().then(function (data) {\n        return _this12.refreshSessionIfPossible(params).then(function () {\n          return data;\n        });\n      }).then(function (data) {\n        return callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n\n    try {\n      callback(null, JSON.parse(userData));\n      return;\n    } catch (err) {\n      this.clearCachedUserData();\n      callback(err, null);\n      return;\n    }\n  }\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */\n  ;\n\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\n    var userData = this.storage.getItem(this.userDataKey);\n    return userData;\n  }\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */\n  ;\n\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\n    var _ref = params || {},\n        _ref$bypassCache = _ref.bypassCache,\n        bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\n\n    return bypassCache;\n  }\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */\n  ;\n\n  _proto.fetchUserData = function fetchUserData() {\n    var _this13 = this;\n\n    return this.createGetUserRequest().then(function (data) {\n      _this13.cacheUserData(data);\n\n      return data;\n    });\n  }\n  /**\n   * This is used by an authenticated user to delete a list of attributes\n   * @param {string[]} attributeList Names of the attributes to delete.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\n    var _this14 = this;\n\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n\n    this.client.request('DeleteUserAttributes', {\n      UserAttributeNames: attributeList,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      } // update cached user\n\n\n      return _this14.getUserData(function () {\n        return callback(null, 'SUCCESS');\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n  /**\n   * This is used by a user to resend a confirmation code\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    this.client.request('ResendConfirmationCode', jsonReq, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return callback(null, result);\n    });\n  }\n  /**\n   * @typedef {Object} GetSessionOptions\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\n   */\n\n  /**\n   * This is used to get a session, either from the session object\n   * or from  the local storage, or by using a refresh token\n   *\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\n   * @param {GetSessionOptions} options\n   * @returns {void}\n   */\n  ;\n\n  _proto.getSession = function getSession(callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (this.username == null) {\n      return callback(new Error('Username is null. Cannot retrieve a new session'), null);\n    }\n\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\n      return callback(null, this.signInUserSession);\n    }\n\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var idTokenKey = keyPrefix + \".idToken\";\n    var accessTokenKey = keyPrefix + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".clockDrift\";\n\n    if (this.storage.getItem(idTokenKey)) {\n      var idToken = new CognitoIdToken({\n        IdToken: this.storage.getItem(idTokenKey)\n      });\n      var accessToken = new CognitoAccessToken({\n        AccessToken: this.storage.getItem(accessTokenKey)\n      });\n      var refreshToken = new CognitoRefreshToken({\n        RefreshToken: this.storage.getItem(refreshTokenKey)\n      });\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\n      var sessionData = {\n        IdToken: idToken,\n        AccessToken: accessToken,\n        RefreshToken: refreshToken,\n        ClockDrift: clockDrift\n      };\n      var cachedSession = new CognitoUserSession(sessionData);\n\n      if (cachedSession.isValid()) {\n        this.signInUserSession = cachedSession;\n        return callback(null, this.signInUserSession);\n      }\n\n      if (!refreshToken.getToken()) {\n        return callback(new Error('Cannot retrieve a new session. Please authenticate.'), null);\n      }\n\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\n    } else {\n      callback(new Error('Local storage is missing an ID Token, Please authenticate'), null);\n    }\n\n    return undefined;\n  }\n  /**\n   * This uses the refreshToken to retrieve a new session\n   * @param {CognitoRefreshToken} refreshToken A previous session's refresh token.\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\n    var _this15 = this;\n\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\n    var authParameters = {};\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n\n    if (this.storage.getItem(lastUserKey)) {\n      this.username = this.storage.getItem(lastUserKey);\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      AuthFlow: 'REFRESH_TOKEN_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        if (err.code === 'NotAuthorizedException') {\n          _this15.clearCachedUser();\n        }\n\n        return wrappedCallback(err, null);\n      }\n\n      if (authResult) {\n        var authenticationResult = authResult.AuthenticationResult;\n\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, 'RefreshToken')) {\n          authenticationResult.RefreshToken = refreshToken.getToken();\n        }\n\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\n\n        _this15.cacheTokens();\n\n        return wrappedCallback(null, _this15.signInUserSession);\n      }\n\n      return undefined;\n    });\n  }\n  /**\n   * This is used to save the session tokens to local storage\n   * @returns {void}\n   */\n  ;\n\n  _proto.cacheTokens = function cacheTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\n    this.storage.setItem(lastUserKey, this.username);\n  }\n  /**\n   * This is to cache user data\n   */\n  ;\n\n  _proto.cacheUserData = function cacheUserData(userData) {\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\n  }\n  /**\n   * This is to remove cached user data\n   */\n  ;\n\n  _proto.clearCachedUserData = function clearCachedUserData() {\n    this.storage.removeItem(this.userDataKey);\n  };\n\n  _proto.clearCachedUser = function clearCachedUser() {\n    this.clearCachedTokens();\n    this.clearCachedUserData();\n  }\n  /**\n   * This is used to cache the device key and device group and device password\n   * @returns {void}\n   */\n  ;\n\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\n  }\n  /**\n   * This is used to get current device key and device group and device password\n   * @returns {void}\n   */\n  ;\n\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n\n    if (this.storage.getItem(deviceKeyKey)) {\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\n    }\n  }\n  /**\n   * This is used to clear the device key info from local storage\n   * @returns {void}\n   */\n  ;\n\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.removeItem(deviceKeyKey);\n    this.storage.removeItem(randomPasswordKey);\n    this.storage.removeItem(deviceGroupKeyKey);\n  }\n  /**\n   * This is used to clear the session tokens from local storage\n   * @returns {void}\n   */\n  ;\n\n  _proto.clearCachedTokens = function clearCachedTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    this.storage.removeItem(idTokenKey);\n    this.storage.removeItem(accessTokenKey);\n    this.storage.removeItem(refreshTokenKey);\n    this.storage.removeItem(lastUserKey);\n    this.storage.removeItem(clockDriftKey);\n  }\n  /**\n   * This is used to build a user session from tokens retrieved in the authentication result\n   * @param {object} authResult Successful auth response from server.\n   * @returns {CognitoUserSession} The new user session.\n   * @private\n   */\n  ;\n\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\n    var idToken = new CognitoIdToken(authResult);\n    var accessToken = new CognitoAccessToken(authResult);\n    var refreshToken = new CognitoRefreshToken(authResult);\n    var sessionData = {\n      IdToken: idToken,\n      AccessToken: accessToken,\n      RefreshToken: refreshToken\n    };\n    return new CognitoUserSession(sessionData);\n  }\n  /**\n   * This is used to initiate a forgot password request\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {inputVerificationCode?} callback.inputVerificationCode\n   *    Optional callback raised instead of onSuccess with response data.\n   * @param {onSuccess} callback.onSuccess Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('ForgotPassword', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n\n      return callback.onSuccess(data);\n    });\n  }\n  /**\n   * This is used to confirm a new password using a confirmationCode\n   * @param {string} confirmationCode Code entered by user.\n   * @param {string} newPassword Confirm new password.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<void>} callback.onSuccess Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ConfirmationCode: confirmationCode,\n      Password: newPassword,\n      ClientMetadata: clientMetadata\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('ConfirmForgotPassword', jsonReq, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n  }\n  /**\n   * This is used to initiate an attribute confirmation request\n   * @param {string} attributeName User attribute that needs confirmation.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {inputVerificationCode} callback.inputVerificationCode Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */\n  ;\n\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('GetUserAttributeVerificationCode', {\n      AttributeName: attributeName,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used to confirm an attribute using a confirmation code\n   * @param {string} attributeName Attribute being confirmed.\n   * @param {string} confirmationCode Code entered by user.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('VerifyUserAttribute', {\n      AttributeName: attributeName,\n      Code: confirmationCode,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used to get the device information using the current device key\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device data.\n   * @returns {void}\n   */\n  ;\n\n  _proto.getDevice = function getDevice(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('GetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n  /**\n   * This is used to forget a specific device\n   * @param {string} deviceKey Device key.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('ForgetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: deviceKey\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used to forget the current device\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.forgetDevice = function forgetDevice(callback) {\n    var _this16 = this;\n\n    this.forgetSpecificDevice(this.deviceKey, {\n      onFailure: callback.onFailure,\n      onSuccess: function onSuccess(result) {\n        _this16.deviceKey = null;\n        _this16.deviceGroupKey = null;\n        _this16.randomPassword = null;\n\n        _this16.clearCachedDeviceKeyAndPassword();\n\n        return callback.onSuccess(result);\n      }\n    });\n  }\n  /**\n   * This is used to set the device status as remembered\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used to set the device status as not remembered\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'not_remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used to list all devices for a user\n   *\n   * @param {int} limit the number of devices returned in a call\n   * @param {string | null} paginationToken the pagination token in case any was returned before\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device list.\n   * @returns {void}\n   */\n  ;\n\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    var requestParams = {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      Limit: limit\n    };\n\n    if (paginationToken) {\n      requestParams.PaginationToken = paginationToken;\n    }\n\n    this.client.request('ListDevices', requestParams, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n  /**\n   * This is used to globally revoke all tokens issued to a user\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */\n  ;\n\n  _proto.globalSignOut = function globalSignOut(callback) {\n    var _this17 = this;\n\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n\n    this.client.request('GlobalSignOut', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      _this17.clearCachedUser();\n\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n  /**\n   * This is used for the user to signOut of the application and clear the cached tokens.\n   * @returns {void}\n   */\n  ;\n\n  _proto.signOut = function signOut(revokeTokenCallback) {\n    var _this18 = this; // If tokens won't be revoked, we just clean the client data.\n\n\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== 'function') {\n      this.cleanClientData();\n      return;\n    }\n\n    this.getSession(function (error, _session) {\n      if (error) {\n        return revokeTokenCallback(error);\n      }\n\n      _this18.revokeTokens(function (err) {\n        _this18.cleanClientData();\n\n        revokeTokenCallback(err);\n      });\n    });\n  };\n\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\n    if (revokeTokenCallback === void 0) {\n      revokeTokenCallback = function revokeTokenCallback() {};\n    }\n\n    if (typeof revokeTokenCallback !== 'function') {\n      throw new Error('Invalid revokeTokenCallback. It should be a function.');\n    }\n\n    var tokensToBeRevoked = [];\n\n    if (!this.signInUserSession) {\n      var error = new Error('User is not authenticated');\n      return revokeTokenCallback(error);\n    }\n\n    if (!this.signInUserSession.getAccessToken()) {\n      var _error = new Error('No Access token available');\n\n      return revokeTokenCallback(_error);\n    }\n\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\n    var accessToken = this.signInUserSession.getAccessToken();\n\n    if (this.isSessionRevocable(accessToken)) {\n      if (refreshToken) {\n        return this.revokeToken({\n          token: refreshToken,\n          callback: revokeTokenCallback\n        });\n      }\n    }\n\n    revokeTokenCallback();\n  };\n\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\n    if (token && typeof token.decodePayload === 'function') {\n      try {\n        var _token$decodePayload = token.decodePayload(),\n            origin_jti = _token$decodePayload.origin_jti;\n\n        return !!origin_jti;\n      } catch (err) {// Nothing to do, token doesnt have origin_jti claim\n      }\n    }\n\n    return false;\n  };\n\n  _proto.cleanClientData = function cleanClientData() {\n    this.signInUserSession = null;\n    this.clearCachedUser();\n  };\n\n  _proto.revokeToken = function revokeToken(_ref2) {\n    var token = _ref2.token,\n        callback = _ref2.callback;\n    this.client.requestWithRetry('RevokeToken', {\n      Token: token,\n      ClientId: this.pool.getClientId()\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback();\n    });\n  }\n  /**\n   * This is used by a user trying to select a given MFA\n   * @param {string} answerChallenge the mfa the user wants\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\n    var _this19 = this;\n\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var jsonReq = {\n      ChallengeName: 'SELECT_MFA_TYPE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session\n    };\n\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n\n      _this19.Session = data.Session;\n\n      if (answerChallenge === 'SMS_MFA') {\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n\n      if (answerChallenge === 'SOFTWARE_TOKEN_MFA') {\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n\n      return undefined;\n    });\n  }\n  /**\n   * This returns the user context data for advanced security feature.\n   * @returns {string} the user context data from CognitoUserPool\n   */\n  ;\n\n  _proto.getUserContextData = function getUserContextData() {\n    var pool = this.pool;\n    return pool.getUserContextData(this.username);\n  }\n  /**\n   * This is used by an authenticated or a user trying to authenticate to associate a TOTP MFA\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\n    var _this20 = this;\n\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('AssociateSoftwareToken', {\n        Session: this.Session\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        _this20.Session = data.Session;\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    } else {\n      this.client.request('AssociateSoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    }\n  }\n  /**\n   * This is used by an authenticated or a user trying to authenticate to verify a TOTP MFA\n   * @param {string} totpCode The MFA code entered by the user.\n   * @param {string} friendlyDeviceName The device name we are assigning to the device.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */\n  ;\n\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\n    var _this21 = this;\n\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('VerifySoftwareToken', {\n        Session: this.Session,\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        _this21.Session = data.Session;\n        var challengeResponses = {};\n        challengeResponses.USERNAME = _this21.username;\n        var jsonReq = {\n          ChallengeName: 'MFA_SETUP',\n          ClientId: _this21.pool.getClientId(),\n          ChallengeResponses: challengeResponses,\n          Session: _this21.Session\n        };\n\n        if (_this21.getUserContextData()) {\n          jsonReq.UserContextData = _this21.getUserContextData();\n        }\n\n        _this21.client.request('RespondToAuthChallenge', jsonReq, function (errRespond, dataRespond) {\n          if (errRespond) {\n            return callback.onFailure(errRespond);\n          }\n\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\n\n          _this21.cacheTokens();\n\n          return callback.onSuccess(_this21.signInUserSession);\n        });\n\n        return undefined;\n      });\n    } else {\n      this.client.request('VerifySoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n\n        return callback.onSuccess(data);\n      });\n    }\n  };\n\n  return CognitoUser;\n}();\n\nexport { CognitoUser as default };","map":{"version":3,"names":["Buffer","Sha256","Platform","BigInteger","AuthenticationHelper","CognitoAccessToken","CognitoIdToken","CognitoRefreshToken","CognitoUserSession","DateHelper","CognitoUserAttribute","StorageHelper","isNavigatorAvailable","navigator","userAgent","isReactNative","CognitoUser","data","Username","Pool","Error","username","pool","Session","client","signInUserSession","authenticationFlowType","storage","Storage","getStorage","keyPrefix","getClientId","userDataKey","_proto","prototype","setSignInUserSession","clearCachedUserData","cacheTokens","getSignInUserSession","getUsername","getAuthenticationFlowType","setAuthenticationFlowType","initiateAuth","authDetails","callback","_this","authParameters","getAuthParameters","USERNAME","clientMetaData","Object","keys","getValidationData","length","getClientMetadata","jsonReq","AuthFlow","ClientId","AuthParameters","ClientMetadata","getUserContextData","UserContextData","request","err","onFailure","challengeName","ChallengeName","challengeParameters","ChallengeParameters","customChallenge","getCognitoUserSession","AuthenticationResult","onSuccess","authenticateUser","authenticateUserPlainUsernamePassword","authenticateUserDefaultAuth","_this2","authenticationHelper","getUserPoolName","dateHelper","serverBValue","salt","deviceKey","DEVICE_KEY","getLargeAValue","errOnAValue","aValue","SRP_A","toString","CHALLENGE_NAME","USER_ID_FOR_SRP","SRP_B","SALT","getCachedDeviceKeyAndPassword","getPasswordAuthenticationKey","getPassword","errOnHkdf","hkdf","dateNow","getNowString","concatBuffer","concat","from","SECRET_BLOCK","awsCryptoHash","update","resultFromAWSCrypto","digestSync","signatureString","challengeResponses","PASSWORD_CLAIM_SECRET_BLOCK","TIMESTAMP","PASSWORD_CLAIM_SIGNATURE","respondToAuthChallenge","challenge","challengeCallback","errChallenge","dataChallenge","code","message","toLowerCase","indexOf","randomPassword","deviceGroupKey","clearCachedDeviceKeyAndPassword","jsonReqResp","ChallengeResponses","errAuthenticate","dataAuthenticate","authenticateUserInternal","undefined","_this3","PASSWORD","authResult","_this4","mfaRequired","selectMFAType","mfaSetup","totpRequired","userAttributes","rawRequiredAttributes","requiredAttributes","userAttributesPrefix","getNewPasswordRequiredChallengeUserAttributePrefix","JSON","parse","i","substr","newPasswordRequired","getDeviceResponse","newDeviceMetadata","NewDeviceMetadata","generateHashDevice","DeviceGroupKey","DeviceKey","errGenHash","deviceSecretVerifierConfig","Salt","getSaltDevices","PasswordVerifier","getVerifierDevices","verifierDevices","getRandomPassword","AccessToken","getAccessToken","getJwtToken","DeviceSecretVerifierConfig","DeviceName","errConfirm","dataConfirm","cacheDeviceKeyAndPassword","UserConfirmationNecessary","completeNewPasswordChallenge","newPassword","requiredAttributeData","clientMetadata","_this5","finalUserAttributes","forEach","key","NEW_PASSWORD","_this6","errAValue","errHkdf","confirmRegistration","confirmationCode","forceAliasCreation","ConfirmationCode","ForceAliasCreation","sendCustomChallengeAnswer","answerChallenge","_this7","ANSWER","sendMFACode","mfaType","_this8","SMS_MFA_CODE","mfaTypeSelection","SOFTWARE_TOKEN_MFA_CODE","changePassword","oldUserPassword","newUserPassword","isValid","PreviousPassword","ProposedPassword","enableMFA","mfaOptions","mfaEnabled","DeliveryMedium","AttributeName","push","MFAOptions","setUserMfaPreference","smsMfaSettings","softwareTokenMfaSettings","SMSMfaSettings","SoftwareTokenMfaSettings","disableMFA","deleteUser","_this9","clearCachedUser","updateAttributes","attributes","_this10","UserAttributes","result","getUserData","bypassCache","getUserAttributes","userData","attributeList","attribute","Name","Value","userAttribute","getMFAOptions","createGetUserRequest","promisifyRequest","refreshSessionIfPossible","options","_this11","Promise","resolve","refresh","getRefreshToken","getToken","refreshSession","params","_this12","getUserDataFromCache","fetchUserData","then","isFetchUserDataAndTokenRequired","getItem","_ref","_ref$bypassCache","_this13","cacheUserData","deleteAttributes","_this14","UserAttributeNames","resendConfirmationCode","getSession","idTokenKey","accessTokenKey","refreshTokenKey","clockDriftKey","idToken","IdToken","accessToken","refreshToken","RefreshToken","clockDrift","parseInt","sessionData","ClockDrift","cachedSession","_this15","wrappedCallback","wrapRefreshSessionCallback","REFRESH_TOKEN","lastUserKey","deviceKeyKey","authenticationResult","hasOwnProperty","call","setItem","getIdToken","getClockDrift","stringify","removeItem","clearCachedTokens","randomPasswordKey","deviceGroupKeyKey","forgotPassword","inputVerificationCode","confirmPassword","Password","getAttributeVerificationCode","attributeName","verifyAttribute","Code","getDevice","forgetSpecificDevice","forgetDevice","_this16","setDeviceStatusRemembered","DeviceRememberedStatus","setDeviceStatusNotRemembered","listDevices","limit","paginationToken","requestParams","Limit","PaginationToken","globalSignOut","_this17","signOut","revokeTokenCallback","_this18","cleanClientData","error","_session","revokeTokens","tokensToBeRevoked","_error","isSessionRevocable","revokeToken","token","decodePayload","_token$decodePayload","origin_jti","_ref2","requestWithRetry","Token","sendMFASelectionAnswer","_this19","associateSoftwareToken","_this20","associateSecretCode","SecretCode","verifySoftwareToken","totpCode","friendlyDeviceName","_this21","UserCode","FriendlyDeviceName","errRespond","dataRespond","default"],"sources":["C:/Users/SourabhMurgod/Documents/web-dev-projects/food-ordering-app/node_modules/amazon-cognito-identity-js/es/CognitoUser.js"],"sourcesContent":["/*!\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Buffer } from 'buffer';\nimport { Sha256 } from '@aws-crypto/sha256-js';\nimport { Platform } from './Platform';\nimport BigInteger from './BigInteger';\nimport AuthenticationHelper from './AuthenticationHelper';\nimport CognitoAccessToken from './CognitoAccessToken';\nimport CognitoIdToken from './CognitoIdToken';\nimport CognitoRefreshToken from './CognitoRefreshToken';\nimport CognitoUserSession from './CognitoUserSession';\nimport DateHelper from './DateHelper';\nimport CognitoUserAttribute from './CognitoUserAttribute';\nimport StorageHelper from './StorageHelper';\n\n/**\n * @callback nodeCallback\n * @template T result\n * @param {*} err The operation failure reason, or null.\n * @param {T} result The operation result.\n */\n\n/**\n * @callback onFailure\n * @param {*} err Failure reason.\n */\n\n/**\n * @callback onSuccess\n * @template T result\n * @param {T} result The operation result.\n */\n\n/**\n * @callback mfaRequired\n * @param {*} details MFA challenge details.\n */\n\n/**\n * @callback customChallenge\n * @param {*} details Custom challenge details.\n */\n\n/**\n * @callback inputVerificationCode\n * @param {*} data Server response.\n */\n\n/**\n * @callback authSuccess\n * @param {CognitoUserSession} session The new session.\n * @param {bool=} userConfirmationNecessary User must be confirmed.\n */\n\nvar isNavigatorAvailable = typeof navigator !== 'undefined';\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? 'react-native' : navigator.userAgent : 'nodejs';\n\n/** @class */\nvar CognitoUser = /*#__PURE__*/function () {\n  /**\n   * Constructs a new CognitoUser object\n   * @param {object} data Creation options\n   * @param {string} data.Username The user's username.\n   * @param {CognitoUserPool} data.Pool Pool containing the user.\n   * @param {object} data.Storage Optional storage object.\n   */\n  function CognitoUser(data) {\n    if (data == null || data.Username == null || data.Pool == null) {\n      throw new Error('Username and Pool information are required.');\n    }\n    this.username = data.Username || '';\n    this.pool = data.Pool;\n    this.Session = null;\n    this.client = data.Pool.client;\n    this.signInUserSession = null;\n    this.authenticationFlowType = 'USER_SRP_AUTH';\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\n  }\n\n  /**\n   * Sets the session for this user\n   * @param {CognitoUserSession} signInUserSession the session\n   * @returns {void}\n   */\n  var _proto = CognitoUser.prototype;\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\n    this.clearCachedUserData();\n    this.signInUserSession = signInUserSession;\n    this.cacheTokens();\n  }\n\n  /**\n   * @returns {CognitoUserSession} the current session for this user\n   */;\n  _proto.getSignInUserSession = function getSignInUserSession() {\n    return this.signInUserSession;\n  }\n\n  /**\n   * @returns {string} the user's username\n   */;\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  }\n\n  /**\n   * @returns {String} the authentication flow type\n   */;\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\n    return this.authenticationFlowType;\n  }\n\n  /**\n   * sets authentication flow type\n   * @param {string} authenticationFlowType New value.\n   * @returns {void}\n   */;\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\n    this.authenticationFlowType = authenticationFlowType;\n  }\n\n  /**\n   * This is used for authenticating the user through the custom authentication flow.\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */;\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\n    var _this = this;\n    var authParameters = authDetails.getAuthParameters();\n    authParameters.USERNAME = this.username;\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'CUSTOM_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('InitiateAuth', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = data.ChallengeName;\n      var challengeParameters = data.ChallengeParameters;\n      if (challengeName === 'CUSTOM_CHALLENGE') {\n        _this.Session = data.Session;\n        return callback.customChallenge(challengeParameters);\n      }\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\n      _this.cacheTokens();\n      return callback.onSuccess(_this.signInUserSession);\n    });\n  }\n\n  /**\n   * This is used for authenticating the user.\n   * stuff\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {newPasswordRequired} callback.newPasswordRequired new\n   *        password and any required attributes are required to continue\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */;\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\n    if (this.authenticationFlowType === 'USER_PASSWORD_AUTH') {\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\n    } else if (this.authenticationFlowType === 'USER_SRP_AUTH' || this.authenticationFlowType === 'CUSTOM_AUTH') {\n      return this.authenticateUserDefaultAuth(authDetails, callback);\n    }\n    return callback.onFailure(new Error('Authentication flow type is invalid.'));\n  }\n\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * It calls the AuthenticationHelper for SRP related\n   * stuff\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {newPasswordRequired} callback.newPasswordRequired new\n   *        password and any required attributes are required to continue\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *        response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */;\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\n    var _this2 = this;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var dateHelper = new DateHelper();\n    var serverBValue;\n    var salt;\n    var authParameters = {};\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    authParameters.USERNAME = this.username;\n    authenticationHelper.getLargeAValue(function (errOnAValue, aValue) {\n      // getLargeAValue callback start\n      if (errOnAValue) {\n        callback.onFailure(errOnAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      if (_this2.authenticationFlowType === 'CUSTOM_AUTH') {\n        authParameters.CHALLENGE_NAME = 'SRP_A';\n      }\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n      var jsonReq = {\n        AuthFlow: _this2.authenticationFlowType,\n        ClientId: _this2.pool.getClientId(),\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetaData\n      };\n      if (_this2.getUserContextData(_this2.username)) {\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\n      }\n      _this2.client.request('InitiateAuth', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\n        serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        salt = new BigInteger(challengeParameters.SALT, 16);\n        _this2.getCachedDeviceKeyAndPassword();\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function (errOnHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errOnHkdf) {\n            callback.onFailure(errOnHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this2.pool.getUserPoolName(), 'utf8'), Buffer.from(_this2.username, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this2.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          if (_this2.deviceKey != null) {\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\n          }\n          var respondToAuthChallenge = function respondToAuthChallenge(challenge, challengeCallback) {\n            return _this2.client.request('RespondToAuthChallenge', challenge, function (errChallenge, dataChallenge) {\n              if (errChallenge && errChallenge.code === 'ResourceNotFoundException' && errChallenge.message.toLowerCase().indexOf('device') !== -1) {\n                challengeResponses.DEVICE_KEY = null;\n                _this2.deviceKey = null;\n                _this2.randomPassword = null;\n                _this2.deviceGroupKey = null;\n                _this2.clearCachedDeviceKeyAndPassword();\n                return respondToAuthChallenge(challenge, challengeCallback);\n              }\n              return challengeCallback(errChallenge, dataChallenge);\n            });\n          };\n          var jsonReqResp = {\n            ChallengeName: 'PASSWORD_VERIFIER',\n            ClientId: _this2.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session,\n            ClientMetadata: clientMetaData\n          };\n          if (_this2.getUserContextData()) {\n            jsonReqResp.UserContextData = _this2.getUserContextData();\n          }\n          respondToAuthChallenge(jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n          });\n          return undefined;\n          // getPasswordAuthenticationKey callback end\n        });\n\n        return undefined;\n      });\n      // getLargeAValue callback end\n    });\n  }\n\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * @param {AuthenticationDetails} authDetails Contains the authentication data.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {mfaRequired} callback.mfaRequired MFA code\n   *        required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @returns {void}\n   */;\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\n    var _this3 = this;\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.PASSWORD = authDetails.getPassword();\n    if (!authParameters.PASSWORD) {\n      callback.onFailure(new Error('PASSWORD parameter is required'));\n      return;\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'USER_PASSWORD_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData(this.username)) {\n      jsonReq.UserContextData = this.getUserContextData(this.username);\n    }\n    // USER_PASSWORD_AUTH happens in a single round-trip: client sends userName and password,\n    // Cognito UserPools verifies password and returns tokens.\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\n    });\n  }\n\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   * @param {object} dataAuthenticate authentication data\n   * @param {object} authenticationHelper helper created\n   * @param {callback} callback passed on from caller\n   * @returns {void}\n   */;\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\n    var _this4 = this;\n    var challengeName = dataAuthenticate.ChallengeName;\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\n    if (challengeName === 'SMS_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === 'SELECT_MFA_TYPE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.selectMFAType(challengeName, challengeParameters);\n    }\n    if (challengeName === 'MFA_SETUP') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaSetup(challengeName, challengeParameters);\n    }\n    if (challengeName === 'SOFTWARE_TOKEN_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.totpRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === 'CUSTOM_CHALLENGE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.customChallenge(challengeParameters);\n    }\n    if (challengeName === 'NEW_PASSWORD_REQUIRED') {\n      this.Session = dataAuthenticate.Session;\n      var userAttributes = null;\n      var rawRequiredAttributes = null;\n      var requiredAttributes = [];\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n      if (challengeParameters) {\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\n      }\n      if (rawRequiredAttributes) {\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\n        }\n      }\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\n    }\n    if (challengeName === 'DEVICE_SRP_AUTH') {\n      this.Session = dataAuthenticate.Session;\n      this.getDeviceResponse(callback);\n      return undefined;\n    }\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n    this.challengeName = challengeName;\n    this.cacheTokens();\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\n    if (newDeviceMetadata == null) {\n      return callback.onSuccess(this.signInUserSession);\n    }\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n      if (errGenHash) {\n        return callback.onFailure(errGenHash);\n      }\n      var deviceSecretVerifierConfig = {\n        Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n        PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n      };\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\n      _this4.client.request('ConfirmDevice', {\n        DeviceKey: newDeviceMetadata.DeviceKey,\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        DeviceName: userAgent\n      }, function (errConfirm, dataConfirm) {\n        if (errConfirm) {\n          return callback.onFailure(errConfirm);\n        }\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n        _this4.cacheDeviceKeyAndPassword();\n        if (dataConfirm.UserConfirmationNecessary === true) {\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\n        }\n        return callback.onSuccess(_this4.signInUserSession);\n      });\n      return undefined;\n    });\n    return undefined;\n  }\n\n  /**\n   * This method is user to complete the NEW_PASSWORD_REQUIRED challenge.\n   * Pass the new password with any new user attributes to be updated.\n   * User attribute keys must be of format userAttributes.<attribute_name>.\n   * @param {string} newPassword new password for this user\n   * @param {object} requiredAttributeData map with values for all required attributes\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {mfaRequired} callback.mfaRequired MFA code required to continue.\n   * @param {customChallenge} callback.customChallenge Custom challenge\n   *         response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\n    var _this5 = this;\n    if (!newPassword) {\n      return callback.onFailure(new Error('New password is required.'));\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n    var finalUserAttributes = {};\n    if (requiredAttributeData) {\n      Object.keys(requiredAttributeData).forEach(function (key) {\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\n      });\n    }\n    finalUserAttributes.NEW_PASSWORD = newPassword;\n    finalUserAttributes.USERNAME = this.username;\n    var jsonReq = {\n      ChallengeName: 'NEW_PASSWORD_REQUIRED',\n      ClientId: this.pool.getClientId(),\n      ChallengeResponses: finalUserAttributes,\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (errAuthenticate, dataAuthenticate) {\n      if (errAuthenticate) {\n        return callback.onFailure(errAuthenticate);\n      }\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to get a session using device authentication. It is called at the end of user\n   * authentication\n   *\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   * @private\n   */;\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\n    var _this6 = this;\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\n    var dateHelper = new DateHelper();\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.DEVICE_KEY = this.deviceKey;\n    authenticationHelper.getLargeAValue(function (errAValue, aValue) {\n      // getLargeAValue callback start\n      if (errAValue) {\n        callback.onFailure(errAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      var jsonReq = {\n        ChallengeName: 'DEVICE_SRP_AUTH',\n        ClientId: _this6.pool.getClientId(),\n        ChallengeResponses: authParameters,\n        ClientMetadata: clientMetadata,\n        Session: _this6.Session\n      };\n      if (_this6.getUserContextData()) {\n        jsonReq.UserContextData = _this6.getUserContextData();\n      }\n      _this6.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        var serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        var salt = new BigInteger(challengeParameters.SALT, 16);\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function (errHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errHkdf) {\n            return callback.onFailure(errHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this6.deviceGroupKey, 'utf8'), Buffer.from(_this6.deviceKey, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this6.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\n          var jsonReqResp = {\n            ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n            ClientId: _this6.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session\n          };\n          if (_this6.getUserContextData()) {\n            jsonReqResp.UserContextData = _this6.getUserContextData();\n          }\n          _this6.client.request('RespondToAuthChallenge', jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n            _this6.cacheTokens();\n            return callback.onSuccess(_this6.signInUserSession);\n          });\n          return undefined;\n          // getPasswordAuthenticationKey callback end\n        });\n\n        return undefined;\n      });\n      // getLargeAValue callback end\n    });\n  }\n\n  /**\n   * This is used for a certain user to confirm the registration by using a confirmation code\n   * @param {string} confirmationCode Code entered by user.\n   * @param {bool} forceAliasCreation Allow migrating from an existing email / phone number.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      ConfirmationCode: confirmationCode,\n      Username: this.username,\n      ForceAliasCreation: forceAliasCreation,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ConfirmSignUp', jsonReq, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n  }\n\n  /**\n   * This is used by the user once he has the responses to a custom challenge\n   * @param {string} answerChallenge The custom challenge answer.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {customChallenge} callback.customChallenge\n   *    Custom challenge response required to continue.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\n    var _this7 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: 'CUSTOM_CHALLENGE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\n    });\n  }\n\n  /**\n   * This is used by the user once he has an MFA code\n   * @param {string} confirmationCode The MFA code entered by the user.\n   * @param {object} callback Result callback map.\n   * @param {string} mfaType The mfa we are replying to.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\n    var _this8 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\n    var mfaTypeSelection = mfaType || 'SMS_MFA';\n    if (mfaTypeSelection === 'SOFTWARE_TOKEN_MFA') {\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\n    }\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: mfaTypeSelection,\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, dataAuthenticate) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = dataAuthenticate.ChallengeName;\n      if (challengeName === 'DEVICE_SRP_AUTH') {\n        _this8.getDeviceResponse(callback);\n        return undefined;\n      }\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n      _this8.cacheTokens();\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\n        return callback.onSuccess(_this8.signInUserSession);\n      }\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n        if (errGenHash) {\n          return callback.onFailure(errGenHash);\n        }\n        var deviceSecretVerifierConfig = {\n          Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n          PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n        };\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\n        _this8.client.request('ConfirmDevice', {\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n          DeviceName: userAgent\n        }, function (errConfirm, dataConfirm) {\n          if (errConfirm) {\n            return callback.onFailure(errConfirm);\n          }\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n          _this8.cacheDeviceKeyAndPassword();\n          if (dataConfirm.UserConfirmationNecessary === true) {\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\n          }\n          return callback.onSuccess(_this8.signInUserSession);\n        });\n        return undefined;\n      });\n      return undefined;\n    });\n  }\n\n  /**\n   * This is used by an authenticated user to change the current password\n   * @param {string} oldUserPassword The current password.\n   * @param {string} newUserPassword The requested new password.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('ChangePassword', {\n      PreviousPassword: oldUserPassword,\n      ProposedPassword: newUserPassword,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by an authenticated user to enable MFA for itself\n   * @deprecated\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.enableMFA = function enableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var mfaOptions = [];\n    var mfaEnabled = {\n      DeliveryMedium: 'SMS',\n      AttributeName: 'phone_number'\n    };\n    mfaOptions.push(mfaEnabled);\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by an authenticated user to enable MFA for itself\n   * @param {IMfaSettings} smsMfaSettings the sms mfa settings\n   * @param {IMFASettings} softwareTokenMfaSettings the software token mfa settings\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('SetUserMFAPreference', {\n      SMSMfaSettings: smsMfaSettings,\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by an authenticated user to disable MFA for itself\n   * @deprecated\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.disableMFA = function disableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var mfaOptions = [];\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by an authenticated user to delete itself\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\n    var _this9 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('DeleteUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      _this9.clearCachedUser();\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * @typedef {CognitoUserAttribute | { Name:string, Value:string }} AttributeArg\n   */\n  /**\n   * This is used by an authenticated user to change a list of attributes\n   * @param {AttributeArg[]} attributes A list of the new user attributes.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\n    var _this10 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('UpdateUserAttributes', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      UserAttributes: attributes,\n      ClientMetadata: clientMetadata\n    }, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      // update cached user\n      return _this10.getUserData(function () {\n        return callback(null, 'SUCCESS', result);\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by an authenticated user to get a list of attributes\n   * @param {nodeCallback<CognitoUserAttribute[]>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.getUserAttributes = function getUserAttributes(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      var attributeList = [];\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\n        var attribute = {\n          Name: userData.UserAttributes[i].Name,\n          Value: userData.UserAttributes[i].Value\n        };\n        var userAttribute = new CognitoUserAttribute(attribute);\n        attributeList.push(userAttribute);\n      }\n      return callback(null, attributeList);\n    });\n    return undefined;\n  }\n\n  /**\n   * This was previously used by an authenticated user to get MFAOptions,\n   * but no longer returns a meaningful response. Refer to the documentation for\n   * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\n   * @deprecated\n   * @param {nodeCallback<MFAOptions>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.getMFAOptions = function getMFAOptions(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, userData.MFAOptions);\n    });\n    return undefined;\n  }\n\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */;\n  _proto.createGetUserRequest = function createGetUserRequest() {\n    return this.client.promisifyRequest('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    });\n  }\n\n  /**\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */;\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\n    var _this11 = this;\n    if (options === void 0) {\n      options = {};\n    }\n    // best effort, if not possible\n    return new Promise(function (resolve) {\n      var refresh = _this11.signInUserSession.getRefreshToken();\n      if (refresh && refresh.getToken()) {\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * @typedef {Object} GetUserDataOptions\n   * @property {boolean} bypassCache - force getting data from Cognito service\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\n   */\n\n  /**\n   * This is used by an authenticated users to get the userData\n   * @param {nodeCallback<UserData>} callback Called on success or error.\n   * @param {GetUserDataOptions} params\n   * @returns {void}\n   */;\n  _proto.getUserData = function getUserData(callback, params) {\n    var _this12 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.clearCachedUserData();\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var userData = this.getUserDataFromCache();\n    if (!userData) {\n      this.fetchUserData().then(function (data) {\n        callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    if (this.isFetchUserDataAndTokenRequired(params)) {\n      this.fetchUserData().then(function (data) {\n        return _this12.refreshSessionIfPossible(params).then(function () {\n          return data;\n        });\n      }).then(function (data) {\n        return callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    try {\n      callback(null, JSON.parse(userData));\n      return;\n    } catch (err) {\n      this.clearCachedUserData();\n      callback(err, null);\n      return;\n    }\n  }\n\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */;\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\n    var userData = this.storage.getItem(this.userDataKey);\n    return userData;\n  }\n\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */;\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\n    var _ref = params || {},\n      _ref$bypassCache = _ref.bypassCache,\n      bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\n    return bypassCache;\n  }\n  /**\n   *\n   * PRIVATE ONLY: This is an internal only method and should not\n   * be directly called by the consumers.\n   */;\n  _proto.fetchUserData = function fetchUserData() {\n    var _this13 = this;\n    return this.createGetUserRequest().then(function (data) {\n      _this13.cacheUserData(data);\n      return data;\n    });\n  }\n\n  /**\n   * This is used by an authenticated user to delete a list of attributes\n   * @param {string[]} attributeList Names of the attributes to delete.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\n    var _this14 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('DeleteUserAttributes', {\n      UserAttributeNames: attributeList,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      // update cached user\n      return _this14.getUserData(function () {\n        return callback(null, 'SUCCESS');\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used by a user to resend a confirmation code\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    this.client.request('ResendConfirmationCode', jsonReq, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, result);\n    });\n  }\n\n  /**\n   * @typedef {Object} GetSessionOptions\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\n   */\n\n  /**\n   * This is used to get a session, either from the session object\n   * or from  the local storage, or by using a refresh token\n   *\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\n   * @param {GetSessionOptions} options\n   * @returns {void}\n   */;\n  _proto.getSession = function getSession(callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (this.username == null) {\n      return callback(new Error('Username is null. Cannot retrieve a new session'), null);\n    }\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\n      return callback(null, this.signInUserSession);\n    }\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var idTokenKey = keyPrefix + \".idToken\";\n    var accessTokenKey = keyPrefix + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".clockDrift\";\n    if (this.storage.getItem(idTokenKey)) {\n      var idToken = new CognitoIdToken({\n        IdToken: this.storage.getItem(idTokenKey)\n      });\n      var accessToken = new CognitoAccessToken({\n        AccessToken: this.storage.getItem(accessTokenKey)\n      });\n      var refreshToken = new CognitoRefreshToken({\n        RefreshToken: this.storage.getItem(refreshTokenKey)\n      });\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\n      var sessionData = {\n        IdToken: idToken,\n        AccessToken: accessToken,\n        RefreshToken: refreshToken,\n        ClockDrift: clockDrift\n      };\n      var cachedSession = new CognitoUserSession(sessionData);\n      if (cachedSession.isValid()) {\n        this.signInUserSession = cachedSession;\n        return callback(null, this.signInUserSession);\n      }\n      if (!refreshToken.getToken()) {\n        return callback(new Error('Cannot retrieve a new session. Please authenticate.'), null);\n      }\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\n    } else {\n      callback(new Error('Local storage is missing an ID Token, Please authenticate'), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * This uses the refreshToken to retrieve a new session\n   * @param {CognitoRefreshToken} refreshToken A previous session's refresh token.\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\n    var _this15 = this;\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\n    var authParameters = {};\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    if (this.storage.getItem(lastUserKey)) {\n      this.username = this.storage.getItem(lastUserKey);\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      AuthFlow: 'REFRESH_TOKEN_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        if (err.code === 'NotAuthorizedException') {\n          _this15.clearCachedUser();\n        }\n        return wrappedCallback(err, null);\n      }\n      if (authResult) {\n        var authenticationResult = authResult.AuthenticationResult;\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, 'RefreshToken')) {\n          authenticationResult.RefreshToken = refreshToken.getToken();\n        }\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\n        _this15.cacheTokens();\n        return wrappedCallback(null, _this15.signInUserSession);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * This is used to save the session tokens to local storage\n   * @returns {void}\n   */;\n  _proto.cacheTokens = function cacheTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\n    this.storage.setItem(lastUserKey, this.username);\n  }\n\n  /**\n   * This is to cache user data\n   */;\n  _proto.cacheUserData = function cacheUserData(userData) {\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\n  }\n\n  /**\n   * This is to remove cached user data\n   */;\n  _proto.clearCachedUserData = function clearCachedUserData() {\n    this.storage.removeItem(this.userDataKey);\n  };\n  _proto.clearCachedUser = function clearCachedUser() {\n    this.clearCachedTokens();\n    this.clearCachedUserData();\n  }\n\n  /**\n   * This is used to cache the device key and device group and device password\n   * @returns {void}\n   */;\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\n  }\n\n  /**\n   * This is used to get current device key and device group and device password\n   * @returns {void}\n   */;\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    if (this.storage.getItem(deviceKeyKey)) {\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\n    }\n  }\n\n  /**\n   * This is used to clear the device key info from local storage\n   * @returns {void}\n   */;\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.removeItem(deviceKeyKey);\n    this.storage.removeItem(randomPasswordKey);\n    this.storage.removeItem(deviceGroupKeyKey);\n  }\n\n  /**\n   * This is used to clear the session tokens from local storage\n   * @returns {void}\n   */;\n  _proto.clearCachedTokens = function clearCachedTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    this.storage.removeItem(idTokenKey);\n    this.storage.removeItem(accessTokenKey);\n    this.storage.removeItem(refreshTokenKey);\n    this.storage.removeItem(lastUserKey);\n    this.storage.removeItem(clockDriftKey);\n  }\n\n  /**\n   * This is used to build a user session from tokens retrieved in the authentication result\n   * @param {object} authResult Successful auth response from server.\n   * @returns {CognitoUserSession} The new user session.\n   * @private\n   */;\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\n    var idToken = new CognitoIdToken(authResult);\n    var accessToken = new CognitoAccessToken(authResult);\n    var refreshToken = new CognitoRefreshToken(authResult);\n    var sessionData = {\n      IdToken: idToken,\n      AccessToken: accessToken,\n      RefreshToken: refreshToken\n    };\n    return new CognitoUserSession(sessionData);\n  }\n\n  /**\n   * This is used to initiate a forgot password request\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {inputVerificationCode?} callback.inputVerificationCode\n   *    Optional callback raised instead of onSuccess with response data.\n   * @param {onSuccess} callback.onSuccess Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ForgotPassword', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(data);\n    });\n  }\n\n  /**\n   * This is used to confirm a new password using a confirmationCode\n   * @param {string} confirmationCode Code entered by user.\n   * @param {string} newPassword Confirm new password.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<void>} callback.onSuccess Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ConfirmationCode: confirmationCode,\n      Password: newPassword,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ConfirmForgotPassword', jsonReq, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n  }\n\n  /**\n   * This is used to initiate an attribute confirmation request\n   * @param {string} attributeName User attribute that needs confirmation.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {inputVerificationCode} callback.inputVerificationCode Called on success.\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\n   * @returns {void}\n   */;\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GetUserAttributeVerificationCode', {\n      AttributeName: attributeName,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to confirm an attribute using a confirmation code\n   * @param {string} attributeName Attribute being confirmed.\n   * @param {string} confirmationCode Code entered by user.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('VerifyUserAttribute', {\n      AttributeName: attributeName,\n      Code: confirmationCode,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to get the device information using the current device key\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device data.\n   * @returns {void}\n   */;\n  _proto.getDevice = function getDevice(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to forget a specific device\n   * @param {string} deviceKey Device key.\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('ForgetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: deviceKey\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to forget the current device\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.forgetDevice = function forgetDevice(callback) {\n    var _this16 = this;\n    this.forgetSpecificDevice(this.deviceKey, {\n      onFailure: callback.onFailure,\n      onSuccess: function onSuccess(result) {\n        _this16.deviceKey = null;\n        _this16.deviceGroupKey = null;\n        _this16.randomPassword = null;\n        _this16.clearCachedDeviceKeyAndPassword();\n        return callback.onSuccess(result);\n      }\n    });\n  }\n\n  /**\n   * This is used to set the device status as remembered\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to set the device status as not remembered\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'not_remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to list all devices for a user\n   *\n   * @param {int} limit the number of devices returned in a call\n   * @param {string | null} paginationToken the pagination token in case any was returned before\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device list.\n   * @returns {void}\n   */;\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    var requestParams = {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      Limit: limit\n    };\n    if (paginationToken) {\n      requestParams.PaginationToken = paginationToken;\n    }\n    this.client.request('ListDevices', requestParams, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used to globally revoke all tokens issued to a user\n   * @param {object} callback Result callback map.\n   * @param {onFailure} callback.onFailure Called on any error.\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\n   * @returns {void}\n   */;\n  _proto.globalSignOut = function globalSignOut(callback) {\n    var _this17 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GlobalSignOut', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this17.clearCachedUser();\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\n   * This is used for the user to signOut of the application and clear the cached tokens.\n   * @returns {void}\n   */;\n  _proto.signOut = function signOut(revokeTokenCallback) {\n    var _this18 = this;\n    // If tokens won't be revoked, we just clean the client data.\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== 'function') {\n      this.cleanClientData();\n      return;\n    }\n    this.getSession(function (error, _session) {\n      if (error) {\n        return revokeTokenCallback(error);\n      }\n      _this18.revokeTokens(function (err) {\n        _this18.cleanClientData();\n        revokeTokenCallback(err);\n      });\n    });\n  };\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\n    if (revokeTokenCallback === void 0) {\n      revokeTokenCallback = function revokeTokenCallback() {};\n    }\n    if (typeof revokeTokenCallback !== 'function') {\n      throw new Error('Invalid revokeTokenCallback. It should be a function.');\n    }\n    var tokensToBeRevoked = [];\n    if (!this.signInUserSession) {\n      var error = new Error('User is not authenticated');\n      return revokeTokenCallback(error);\n    }\n    if (!this.signInUserSession.getAccessToken()) {\n      var _error = new Error('No Access token available');\n      return revokeTokenCallback(_error);\n    }\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\n    var accessToken = this.signInUserSession.getAccessToken();\n    if (this.isSessionRevocable(accessToken)) {\n      if (refreshToken) {\n        return this.revokeToken({\n          token: refreshToken,\n          callback: revokeTokenCallback\n        });\n      }\n    }\n    revokeTokenCallback();\n  };\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\n    if (token && typeof token.decodePayload === 'function') {\n      try {\n        var _token$decodePayload = token.decodePayload(),\n          origin_jti = _token$decodePayload.origin_jti;\n        return !!origin_jti;\n      } catch (err) {\n        // Nothing to do, token doesnt have origin_jti claim\n      }\n    }\n    return false;\n  };\n  _proto.cleanClientData = function cleanClientData() {\n    this.signInUserSession = null;\n    this.clearCachedUser();\n  };\n  _proto.revokeToken = function revokeToken(_ref2) {\n    var token = _ref2.token,\n      callback = _ref2.callback;\n    this.client.requestWithRetry('RevokeToken', {\n      Token: token,\n      ClientId: this.pool.getClientId()\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    });\n  }\n\n  /**\n   * This is used by a user trying to select a given MFA\n   * @param {string} answerChallenge the mfa the user wants\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\n    var _this19 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var jsonReq = {\n      ChallengeName: 'SELECT_MFA_TYPE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this19.Session = data.Session;\n      if (answerChallenge === 'SMS_MFA') {\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      if (answerChallenge === 'SOFTWARE_TOKEN_MFA') {\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * This returns the user context data for advanced security feature.\n   * @returns {string} the user context data from CognitoUserPool\n   */;\n  _proto.getUserContextData = function getUserContextData() {\n    var pool = this.pool;\n    return pool.getUserContextData(this.username);\n  }\n\n  /**\n   * This is used by an authenticated or a user trying to authenticate to associate a TOTP MFA\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\n    var _this20 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('AssociateSoftwareToken', {\n        Session: this.Session\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this20.Session = data.Session;\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    } else {\n      this.client.request('AssociateSoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    }\n  }\n\n  /**\n   * This is used by an authenticated or a user trying to authenticate to verify a TOTP MFA\n   * @param {string} totpCode The MFA code entered by the user.\n   * @param {string} friendlyDeviceName The device name we are assigning to the device.\n   * @param {nodeCallback<string>} callback Called on success or error.\n   * @returns {void}\n   */;\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\n    var _this21 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('VerifySoftwareToken', {\n        Session: this.Session,\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this21.Session = data.Session;\n        var challengeResponses = {};\n        challengeResponses.USERNAME = _this21.username;\n        var jsonReq = {\n          ChallengeName: 'MFA_SETUP',\n          ClientId: _this21.pool.getClientId(),\n          ChallengeResponses: challengeResponses,\n          Session: _this21.Session\n        };\n        if (_this21.getUserContextData()) {\n          jsonReq.UserContextData = _this21.getUserContextData();\n        }\n        _this21.client.request('RespondToAuthChallenge', jsonReq, function (errRespond, dataRespond) {\n          if (errRespond) {\n            return callback.onFailure(errRespond);\n          }\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\n          _this21.cacheTokens();\n          return callback.onSuccess(_this21.signInUserSession);\n        });\n        return undefined;\n      });\n    } else {\n      this.client.request('VerifySoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.onSuccess(data);\n      });\n    }\n  };\n  return CognitoUser;\n}();\nexport { CognitoUser as default };"],"mappings":"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"},"metadata":{},"sourceType":"module"}